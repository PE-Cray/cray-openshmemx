<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>shmemx_alltoallv</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="summary">Summary</h1>
<pre><code>shmemx_alltoallv is a cray-specific collective routine, where each PE in the
defined set exchanges distinct data with all other PEs in the active set.</code></pre>
<h1 id="definitions">Definitions</h1>
<h2 id="c-or-c-synopsis">C or C++ SYNOPSIS</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ex">void</span> shmemx_alltoallv(void *target, size_t t_offsets, size_t t_sizes,</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">                      <span class="ex">const</span> void *source, size_t s_offsets, size_t s_sizes,</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">                      <span class="ex">int</span> PE_start, int logPE_stride, int PE_size, long *pSync)</a></code></pre></div>
<h1 id="deprecated-synopsis">Deprecated Synopsis</h1>
<h2 id="deprecated-fortran-synopsis">Deprecated Fortran Synopsis</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ex">INTEGER</span> pSync(SHMEM_ALLTOALL_SYNC_SIZE)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ex">INTEGER</span> PE_start, logPE_stride, PE_size, nelems</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ex">INTEGER</span> (KIND=8) <span class="ex">t_offsets</span>(*), <span class="ex">t_sizes</span>(*), <span class="ex">s_offsets</span>(*), <span class="ex">s_sizes</span>(*)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="op">&lt;</span><span class="ex">TYPE</span><span class="op">&gt;</span>  target(*), <span class="bu">source</span>(*)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="ex">CALL</span> SHMEMX_ALLTOALLV(target, t_offsets, t_sizes, source, s_offsets,</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">                      <span class="ex">s_sizes</span>, PE_start, logPE_stride, PE_size, pSync)</a></code></pre></div>
<h1 id="arguments">Arguments</h1>
<pre><code>   target    A symmetric array large enough to receive the data being sent
             from each PE in the active set.

   t_offsets A symmetric array with PE_size entries. Entry i specifies the
             offset (relative to target) at which to place the incoming data
             from PE i.

   t_sizes   A symmetric array with PE_size entries. On function return,
             entry i will contain the number of bytes received from PE i.

   source    A symmetric array that contains the data to be sent to each PE
             in the active set.

   s_offsets A symmetric array with PE_size entries. Entry i specifies the
             offset (relative to source) of the starting address of the data
             to be sent to PE i.

   s_sizes   A symmetric array with PE_size entries. Entry i specifies the
             amount of data (in bytes) that will be sent to PE i.

   PE_start  The lowest virtual PE number of the active set of PEs.

   logPE_stride
             The log (base 2) of the stride between consecutive virtual PE
             numbers in the active set.

   PE_size   The number of PEs in the active set.

   pSync     A symmetric work array. Every element of this array must be
             initialized with the value SHMEM_SYNC_VALUE before any of the
             PEs in the active set enter shmemx_alltoallv.

   The values of arguments PE_start, logPE_stride, and PE_size must be equal
   on all PEs in the active set. The same target and source arrays, and the
   same pSync work array must be passed to all PEs in the active set.

   Before any PE calls shmemx_alltoallv, the following conditions must exist
   (synchronization via a barrier or some other method is often needed to
    ensure this).

   The pSync array on all PEs in the active set is not still in use from a
   prior call to a shmemx_alltoallv routine.

   The target array on all PEs in the active set is ready to accept the
   shmemx_alltoallv data.</code></pre>
<h1 id="description">Description</h1>
<pre><code>The shmemx_alltoallv routine is a collective routine, each PE in the
defined set exchanges distinct data with all other PEs in the set. Each
PE specifies an array of source offsets and source sizes (in bytes) that
describe what data to send to each of the other PEs in the set. The
caller also specifies a target buffer and a target offset array that
specifies where data received from each of the other PEs is deposited.
The t_sizes array is an output parameter. On return from the collective,
the t_sizes array contains the actual amount of data in bytes the local PE
received from each PE.

The shmemx_alltoallv routine requires each PE to allocate its target
array large enough to hold the incoming data. If the caller calculates
the t_offsets using a smaller maximum size than is being used by one
or more of the senders, data may be overwritten. To aid in debugging
this scenario an optional target size check may be requested by setting
the SHMEM_ALLTOALLV_TSIZE_CHK environment variable to abort
or trunc. If set, the user must supply the maximum number of bytes
allowed from each PE in the t_sizes array upon function entry. See
the intro_shmem(3) man page for more information on SHMEM_ALLTOALLV_TSIZE_CHK.

As with all Cray OpenSHMEMX collectives, this routine assumes that only PEs
in the active set call the routine. If a PE that is not in the active
set calls a Cray OpenSHMEMX collective routine, undefined behavior results.</code></pre>
<h1 id="notes">Notes</h1>
<pre><code>The shmemx_alltoallv routine sets the values in pSync based on
PE_start, logPE_stride, and PE_size values; therefore, a
particular pSync buffer need only be initialized the first time it is
used.

Ensure that the pSync array is not being updated by any PE in the
active set while any of the PEs participate in the processing of a
shmem_alltoallv routine. Be careful to avoid these situations:

-   If the pSync array is initialized at run time, some type of
    synchronization is needed to ensure that all PEs in the working set
    have initialized pSync before any of them enter a Cray OpenSHMEMX
    routine.
-   A pSync array may be reused in a subsequent call to
    shmemx_alltoallv only if none of the PEs in the active set are
    still processing a prior call to shmemx_alltoallv that used the
    same pSync array. In general, this can be ensured only by doing
    some type of synchronization. However, in the special case of Cray
    SHMEM routines being called with the same active set, it is
    permissible to allocate two pSync arrays and alternate between
    them on successive calls.

There are several Cray OpenSHMEMX environment variables that can alter the
specific algorithm used and, therefore, the performance of the
shmemx_alltoallv collective. Please see the intro_shmem(3) man page for more
information on these environment variables.</code></pre>
<h1 id="examples">Examples</h1>
<h2 id="cc-example">C/C++ Example</h2>
<pre><code>This C example shows shmemx_alltoallv exchanging variable sized data
amounts among all PEs.</code></pre>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">#include &lt;shmem.h&gt;</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="co">#include &lt;shmemx.h&gt;</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="co">#include &lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="ex">int</span> main(void)</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="kw">{</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    <span class="ex">static</span> long pSync[SHMEM_ALLTOALL_SYNC_SIZE]<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    <span class="ex">long</span> *source, *target<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    <span class="ex">size_t</span> *s_offsets, *s_sizes, *t_offsets, *t_sizes, offset<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">    <span class="ex">int</span>  i, maxcount, pe, idx<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11"></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">    <span class="fu">shmem_init()</span>;</a>
<a class="sourceLine" id="cb8-13" data-line-number="13"></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">    <span class="ex">maxcount</span>  = shmem_n_pes();</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">    <span class="ex">target</span>    = (long *) <span class="ex">shmem_malloc</span>(maxcount * shmem_n_pes() <span class="ex">*</span> sizeof(long));</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">    <span class="bu">source</span>    = (long *) <span class="ex">shmem_malloc</span>(maxcount * shmem_n_pes() <span class="ex">*</span> sizeof(long));</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">    <span class="ex">s_offsets</span> = (size_t *) <span class="ex">shmem_malloc</span>(shmem_n_pes() <span class="ex">*</span> sizeof(size_t));</a>
<a class="sourceLine" id="cb8-18" data-line-number="18">    <span class="ex">s_sizes</span>   = (size_t *) <span class="ex">shmem_malloc</span>(shmem_n_pes() <span class="ex">*</span> sizeof(size_t));</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">    <span class="ex">t_offsets</span> = (size_t *) <span class="ex">shmem_malloc</span>(shmem_n_pes() <span class="ex">*</span> sizeof(size_t));</a>
<a class="sourceLine" id="cb8-20" data-line-number="20">    <span class="ex">t_sizes</span>   = (size_t *) <span class="ex">shmem_malloc</span>(shmem_n_pes() <span class="ex">*</span> sizeof(size_t));</a>
<a class="sourceLine" id="cb8-21" data-line-number="21"></a>
<a class="sourceLine" id="cb8-22" data-line-number="22">    <span class="ex">s_offsets</span>[0] = 0<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-23" data-line-number="23">    <span class="kw">for</span> <span class="kw">(</span><span class="va">pe=</span>0; <span class="ex">pe</span> <span class="op">&lt;</span>shmem_n_pes(<span class="kw">)</span>; <span class="ex">pe++</span>) <span class="kw">{</span></a>
<a class="sourceLine" id="cb8-24" data-line-number="24"></a>
<a class="sourceLine" id="cb8-25" data-line-number="25">        <span class="ex">/*</span> set source sizes, no need to set target sizes */</a>
<a class="sourceLine" id="cb8-26" data-line-number="26">        <span class="ex">s_sizes</span>[pe] = pe * sizeof(long);</a>
<a class="sourceLine" id="cb8-27" data-line-number="27">        <span class="ex">t_sizes</span>[pe] = 0<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-28" data-line-number="28"></a>
<a class="sourceLine" id="cb8-29" data-line-number="29">        <span class="ex">/*</span> calculate source offsets */</a>
<a class="sourceLine" id="cb8-30" data-line-number="30">        <span class="kw">if</span> <span class="kw">(</span><span class="ex">pe</span> <span class="op">&gt;</span> 0<span class="kw">)</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb8-31" data-line-number="31">           <span class="ex">s_offsets</span>[pe] = s_offsets[pe-1] + s_sizes[pe-1]<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-32" data-line-number="32">        <span class="kw">}</span></a>
<a class="sourceLine" id="cb8-33" data-line-number="33"></a>
<a class="sourceLine" id="cb8-34" data-line-number="34">        <span class="ex">/*</span> calculate target offsets */</a>
<a class="sourceLine" id="cb8-35" data-line-number="35">        <span class="ex">t_offsets</span>[pe] = (shmem_my_pe() <span class="ex">*</span> sizeof(long)) <span class="ex">*</span> pe<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-36" data-line-number="36">    <span class="kw">}</span></a>
<a class="sourceLine" id="cb8-37" data-line-number="37"></a>
<a class="sourceLine" id="cb8-38" data-line-number="38">    <span class="ex">/*</span> assign source values */</a>
<a class="sourceLine" id="cb8-39" data-line-number="39">    <span class="kw">for</span> <span class="kw">(</span><span class="va">idx=</span>0,pe=<span class="ex">0</span><span class="kw">;</span> <span class="ex">pe</span><span class="op">&lt;</span>shmem_n_pes(<span class="kw">)</span>; <span class="ex">pe++</span>) <span class="kw">{</span></a>
<a class="sourceLine" id="cb8-40" data-line-number="40">        <span class="kw">for</span> <span class="kw">(</span><span class="va">i=</span>0; <span class="ex">i</span><span class="op">&lt;</span>s_sizes[pe]/sizeof(long<span class="kw">)</span>; <span class="ex">i++</span>) <span class="kw">{</span></a>
<a class="sourceLine" id="cb8-41" data-line-number="41">            <span class="ex">source</span>[idx++] = shmem_my_pe();</a>
<a class="sourceLine" id="cb8-42" data-line-number="42">        <span class="kw">}</span></a>
<a class="sourceLine" id="cb8-43" data-line-number="43">    <span class="kw">}</span></a>
<a class="sourceLine" id="cb8-44" data-line-number="44"></a>
<a class="sourceLine" id="cb8-45" data-line-number="45">    <span class="kw">for</span> <span class="kw">(</span><span class="va">i=</span>0; <span class="ex">i</span> <span class="op">&lt;</span> _SHMEM_ALLTOALL_SYNC_SIZE<span class="kw">;</span> <span class="ex">i++</span><span class="kw">)</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb8-46" data-line-number="46">        <span class="ex">pSync</span>[i] = _SHMEM_SYNC_VALUE<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-47" data-line-number="47">    <span class="kw">}</span></a>
<a class="sourceLine" id="cb8-48" data-line-number="48"></a>
<a class="sourceLine" id="cb8-49" data-line-number="49">    <span class="ex">/*</span> wait for all PEs to initialize pSync */</a>
<a class="sourceLine" id="cb8-50" data-line-number="50">    <span class="fu">shmem_barrier_all()</span>;</a>
<a class="sourceLine" id="cb8-51" data-line-number="51"></a>
<a class="sourceLine" id="cb8-52" data-line-number="52">    <span class="ex">/*</span> alltoallv on all PES */</a>
<a class="sourceLine" id="cb8-53" data-line-number="53">    <span class="ex">shmemx_alltoallv</span>(target, t_offsets, t_sizes, source,</a>
<a class="sourceLine" id="cb8-54" data-line-number="54">                     <span class="ex">s_offsets</span>, s_sizes, 0, 0, shmem_n_pes(), <span class="ex">pSync</span>);</a>
<a class="sourceLine" id="cb8-55" data-line-number="55"></a>
<a class="sourceLine" id="cb8-56" data-line-number="56">    <span class="ex">/*</span> verify results */</a>
<a class="sourceLine" id="cb8-57" data-line-number="57">    <span class="kw">for</span> <span class="kw">(</span><span class="va">pe=</span>0; <span class="ex">pe</span><span class="op">&lt;</span>shmem_n_pes(<span class="kw">)</span>; <span class="ex">pe++</span>) <span class="kw">{</span></a>
<a class="sourceLine" id="cb8-58" data-line-number="58">        <span class="ex">offset</span> = t_offsets[pe] / sizeof(long);</a>
<a class="sourceLine" id="cb8-59" data-line-number="59">        <span class="kw">for</span> <span class="kw">(</span><span class="va">i=</span>0; <span class="ex">i</span><span class="op">&lt;</span>t_sizes[pe]/sizeof(long<span class="kw">)</span>; <span class="ex">i++</span>) <span class="kw">{</span></a>
<a class="sourceLine" id="cb8-60" data-line-number="60">            <span class="kw">if</span> <span class="kw">(</span><span class="ex">target</span>[offset] != pe<span class="kw">)</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb8-61" data-line-number="61">                <span class="bu">printf</span>(<span class="st">&quot;[%d] ERROR: target[%d]=%ld, should be %d\n&quot;</span>,</a>
<a class="sourceLine" id="cb8-62" data-line-number="62">                       <span class="fu">shmem_my_pe()</span>, <span class="ex">offset</span>, target[offset], pe);</a>
<a class="sourceLine" id="cb8-63" data-line-number="63">            <span class="kw">}</span></a>
<a class="sourceLine" id="cb8-64" data-line-number="64">            <span class="ex">offset++</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb8-65" data-line-number="65">        <span class="kw">}</span></a>
<a class="sourceLine" id="cb8-66" data-line-number="66">    <span class="kw">}</span></a>
<a class="sourceLine" id="cb8-67" data-line-number="67"></a>
<a class="sourceLine" id="cb8-68" data-line-number="68">    <span class="fu">shmem_barrier_all()</span>;</a>
<a class="sourceLine" id="cb8-69" data-line-number="69">    <span class="ex">shmem_free</span>(s_offsets);</a>
<a class="sourceLine" id="cb8-70" data-line-number="70">    <span class="ex">shmem_free</span>(s_sizes);</a>
<a class="sourceLine" id="cb8-71" data-line-number="71">    <span class="ex">shmem_free</span>(t_offsets);</a>
<a class="sourceLine" id="cb8-72" data-line-number="72">    <span class="ex">shmem_free</span>(t_sizes);</a>
<a class="sourceLine" id="cb8-73" data-line-number="73">    <span class="ex">shmem_free</span>(target);</a>
<a class="sourceLine" id="cb8-74" data-line-number="74">    <span class="ex">shmem_free</span>(source);</a>
<a class="sourceLine" id="cb8-75" data-line-number="75"></a>
<a class="sourceLine" id="cb8-76" data-line-number="76">    <span class="fu">shmem_finalize()</span>;</a>
<a class="sourceLine" id="cb8-77" data-line-number="77">    <span class="bu">return</span> 0<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-78" data-line-number="78"><span class="kw">}</span></a></code></pre></div>
</body>
</html>
