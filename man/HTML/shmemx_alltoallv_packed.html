<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>shmemx_alltoallv_packed</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body><h1><a href="../main.html">Index</a></h1>
<h1 id="summary">Summary</h1>
<pre><code>shmemx_alltoallv_packed - Each PE exchanges distinct data with all other PEs
in the defined set. Each PE may send a different amount of data and provide
offsets for the source data. The incoming data is deposited in the target
array in a contiguous manner, but the specific order of the data in the
target array is indeterminate. The total number of bytes deposited in the
target array is returned in the t_size parameter.</code></pre>
<h1 id="definitions">Definitions</h1>
<h2 id="c-or-c-synopsis">C or C++ SYNOPSIS</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ex">void</span> shmemx_alltoallv_packed(void *target, size_t target_len, size_t *t_size,</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">                             <span class="ex">const</span> void *source, size_t *s_offsets,</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">                             <span class="ex">size_t</span> *s_sizes, int PE_start, int logPE_stride,</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">                             <span class="ex">int</span> PE_size, long *pSync)</a></code></pre></div>
<h1 id="deprecated-synopsis">Deprecated Synopsis</h1>
<h2 id="deprecated-fortran-synopsis">Deprecated Fortran Synopsis</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ex">INTEGER</span> pSync(SHMEM_ALLTOALL_SYNC_SIZE)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ex">INTEGER</span> PE_start, logPE_stride, PE_size</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ex">INTEGER</span> (KIND=8) <span class="ex">s_offsets</span>(*), <span class="ex">s_sizes</span>(*)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ex">INTEGER</span> (KIND=8) <span class="ex">target_len</span>, t_size</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="op">&lt;</span><span class="ex">TYPE</span><span class="op">&gt;</span> target(*), <span class="bu">source</span>(*)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="ex">CALL</span> SHMEM_ALLTOALLV_PACKED(target, target_len, t_size, source, s_offsets,</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">                            <span class="ex">s_sizes</span>, PE_start, logPE_stride, PE_size, pSync)</a></code></pre></div>
<h1 id="arguments">Arguments</h1>
<pre><code>   target    A symmetric array large enough to receive the data being sent
             from each PE in the active set.

   target_len
             The total number of bytes allocated for the target array.

   t_size    An output variable that upon function return will contain the
             total number of bytes deposited in the target array.

   source    A symmetric array that contains the data to be sent to each PE
             in the active set.

   s_offsets A symmetric array with PE_size entries. Entry i specifies the
             offset (relative to source) of the starting address of the data
             to be sent to PE i.

   s_sizes   A symmetric array with PE_size entries. Entry i specifies the
             amount of data (in bytes) that will be sent to PE i.

   PE_start  The lowest virtual PE number of the active set of PEs.

   logPE_stride
             The log (base 2) of the stride between consecutive virtual PE
             numbers in the active set.

   PE_size   The number of PEs in the active set.

   pSync     A symmetric work array. Every element of this array must be
             initialized with the value SHMEM_SYNC_VALUE before any of the
             PEs in the active set enter shmemx_alltoallv_packed.

   The values of arguments PE_start, logPE_stride, and PE_size must be equal
   on all PEs in the active set. The same target and source arrays, and
   the same s_offset and s_sizes arrays, and the same pSync work array must
   be passed to all PEs in the active set.

   Before any PE calls shmemx_alltoallv_packed, the following conditions must
   exist (synchronization via a barrier or some other method is often needed
   to ensure this).

   The pSync array on all PEs in the active set is not still in use from a
   prior call to a shmemx_alltoallv_packed routine.

   The target array on all PEs in the active set is ready to accept the
   shmemx_alltoallv_packed data.</code></pre>
<h1 id="description">Description</h1>
<pre><code>   The shmemx_alltoallv_packed routine is a collective routine; each PE in
   the defined set exchanges distinct data with all other PEs in the set.
   Each PE specifies an array of source offsets and source sizes (in
   bytes) that describe what data to send to each of the other PEs in the
   set. The caller also specifies a target buffer and a target length. The
   target_len parameter specifies the maximum number of bytes allocated
   for the target buffer. On return from this collective, the t_size
   parameter contains the actual amount of data (in bytes) deposited in the
   local target buffer.

   The shmem_alltoallv_packed routine requires each PE to allocate its target
   array large enough to hold the incoming data. If the target array is not
   allocated large enough to hold all the incoming data, overwriting of the
   target array may occur. To aid in debugging this scenario an optional
   target size check may be requested by setting the SHMEM_ALLTOALLV_TSIZE_CHK
   environment variable to abort or trunc. See the intro_shmem(3) man page
   for more information on SHMEM_ALLTOALLV_TSIZE_CHK.

   As with all Cray SHMEM collectives, this routine assumes that only PEs in
   the active set call the routine. If a PE that is not in the active set
   calls a Cray SHMEM collective routine, undefined behavior results.</code></pre>
<h1 id="notes">Notes</h1>
<pre><code>   The shmem_alltoallv_packed routine sets the values in pSync based on
   PE_start, logPE_stride, and PE_size values; therefore, a particular pSync
   buffer need only be initialized the first time it is used.

   Ensure that the pSync array is not being updated by any PE in the active
   set while any of the PEs participate in the processing of a
   shmem_alltoallv_packed routine. Be careful to avoid these situations:

    - If the pSync array is initialized at run time, some type of
    synchronization is needed to ensure that all PEs in the working set have
    initialized pSync before any of them enter a Cray SHMEM routine.

    - A pSync array may be reused in a subsequent call to
    shmem_alltoallv_packed only if none of the PEs in the active set are
    still processing a prior call to shmem_alltoallv_packed that used the
    same pSync array. In general, this can be ensured only by doing some
    type of synchronization. However, in the special case of Cray SHMEM
    outines being called with the same active set, it is permissible to
    allocate two pSync arrays and alternate between them on successive calls.

    There are several Cray SHMEM environment variables that can alter the
    specific algorithm used and, therefore, the performance of the
    shmem_alltoallv_packed collective. Please see the intro_shmem(3) man page
    for more information on these environment variables.</code></pre>
<h1 id="examples">Examples</h1>
<h2 id="cc-example">C/C++ Example</h2>
<pre><code> This C example shows shmem_alltoallv_packed exchanging 64 integer values
 among all PEs.</code></pre>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">#include &lt;shmem.h&gt;</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="co">#include &lt;shmemx.h&gt;</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="co">#include &lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="co">#include &lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="co">#include &lt;strings.h&gt;</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="ex">int</span> main(void)</a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="kw">{</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    <span class="ex">static</span> long pSync[SHMEM_ALLTOALL_SYNC_SIZE]<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">    <span class="ex">int</span> *source, *target, *counts<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">    <span class="ex">size_t</span> *s_offsets, *s_sizes<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">    <span class="ex">size_t</span> target_len, t_size, expected_tsize<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    <span class="ex">int</span>  i, maxcount, pe, idx<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14"></a>
<a class="sourceLine" id="cb8-15" data-line-number="15">    <span class="fu">shmem_init()</span>;</a>
<a class="sourceLine" id="cb8-16" data-line-number="16"></a>
<a class="sourceLine" id="cb8-17" data-line-number="17">    <span class="ex">maxcount</span>  = 64<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-18" data-line-number="18">    <span class="ex">target</span>    = (int *) <span class="ex">shmem_malloc</span>(maxcount * shmem_n_pes() <span class="ex">*</span> sizeof(int));</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">    <span class="bu">source</span>    = (int *) <span class="ex">shmem_malloc</span>(maxcount * shmem_n_pes() <span class="ex">*</span> sizeof(int));</a>
<a class="sourceLine" id="cb8-20" data-line-number="20">    <span class="ex">s_offsets</span> = (size_t *) <span class="ex">shmem_malloc</span>(shmem_n_pes() <span class="ex">*</span> sizeof(size_t));</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">    <span class="ex">s_sizes</span>   = (size_t *) <span class="ex">shmem_malloc</span>(shmem_n_pes() <span class="ex">*</span> sizeof(size_t));</a>
<a class="sourceLine" id="cb8-22" data-line-number="22"></a>
<a class="sourceLine" id="cb8-23" data-line-number="23">    <span class="ex">target_len</span>     = maxcount * shmem_n_pes() <span class="ex">*</span> sizeof(int);</a>
<a class="sourceLine" id="cb8-24" data-line-number="24">    <span class="ex">t_size</span>         = 0<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-25" data-line-number="25">    <span class="ex">expected_tsize</span> = target_len<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-26" data-line-number="26"></a>
<a class="sourceLine" id="cb8-27" data-line-number="27">    <span class="kw">for</span> <span class="kw">(</span><span class="va">pe=</span>0; <span class="ex">pe</span> <span class="op">&lt;</span>shmem_n_pes(<span class="kw">)</span>; <span class="ex">pe++</span>) <span class="kw">{</span></a>
<a class="sourceLine" id="cb8-28" data-line-number="28">        <span class="ex">/*</span> set source sizes */</a>
<a class="sourceLine" id="cb8-29" data-line-number="29">        <span class="ex">s_sizes</span>[pe] = maxcount * sizeof(int);</a>
<a class="sourceLine" id="cb8-30" data-line-number="30"></a>
<a class="sourceLine" id="cb8-31" data-line-number="31">        <span class="ex">/*</span> calculate source offsets */</a>
<a class="sourceLine" id="cb8-32" data-line-number="32">        <span class="ex">s_offsets</span>[pe] = pe * maxcount * sizeof(int);</a>
<a class="sourceLine" id="cb8-33" data-line-number="33">    <span class="kw">}</span></a>
<a class="sourceLine" id="cb8-34" data-line-number="34"></a>
<a class="sourceLine" id="cb8-35" data-line-number="35">    <span class="ex">/*</span> assign source values */</a>
<a class="sourceLine" id="cb8-36" data-line-number="36">    <span class="kw">for</span> <span class="kw">(</span><span class="va">idx=</span>0,pe=<span class="ex">0</span><span class="kw">;</span> <span class="ex">pe</span><span class="op">&lt;</span>shmem_n_pes(<span class="kw">)</span>; <span class="ex">pe++</span>) <span class="kw">{</span></a>
<a class="sourceLine" id="cb8-37" data-line-number="37">        <span class="kw">for</span> <span class="kw">(</span><span class="va">i=</span>0; <span class="ex">i</span><span class="op">&lt;</span>s_sizes[pe]/sizeof(int<span class="kw">)</span>; <span class="ex">i++</span>) <span class="kw">{</span></a>
<a class="sourceLine" id="cb8-38" data-line-number="38">            <span class="ex">source</span>[idx++] = shmem_my_pe();</a>
<a class="sourceLine" id="cb8-39" data-line-number="39">        <span class="kw">}</span></a>
<a class="sourceLine" id="cb8-40" data-line-number="40">    <span class="kw">}</span></a>
<a class="sourceLine" id="cb8-41" data-line-number="41"></a>
<a class="sourceLine" id="cb8-42" data-line-number="42">    <span class="kw">for</span> <span class="kw">(</span><span class="va">i=</span>0; <span class="ex">i</span> <span class="op">&lt;</span> _SHMEM_ALLTOALL_SYNC_SIZE<span class="kw">;</span> <span class="ex">i++</span><span class="kw">)</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb8-43" data-line-number="43">        <span class="ex">pSync</span>[i] = _SHMEM_SYNC_VALUE<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-44" data-line-number="44">    <span class="kw">}</span></a>
<a class="sourceLine" id="cb8-45" data-line-number="45"></a>
<a class="sourceLine" id="cb8-46" data-line-number="46">    <span class="ex">/*</span> wait for all PEs to initialize pSync */</a>
<a class="sourceLine" id="cb8-47" data-line-number="47">    <span class="fu">shmem_barrier_all()</span>;</a>
<a class="sourceLine" id="cb8-48" data-line-number="48"></a>
<a class="sourceLine" id="cb8-49" data-line-number="49">    <span class="ex">/*</span> alltoallv on all PES */</a>
<a class="sourceLine" id="cb8-50" data-line-number="50">    <span class="ex">shmemx_alltoallv_packed</span>(target, target_len, <span class="kw">&amp;</span><span class="ex">t_size</span>, source,</a>
<a class="sourceLine" id="cb8-51" data-line-number="51">                            <span class="ex">s_offsets</span>, s_sizes, 0, 0, shmem_n_pes(), <span class="ex">pSync</span>);</a>
<a class="sourceLine" id="cb8-52" data-line-number="52"></a>
<a class="sourceLine" id="cb8-53" data-line-number="53">    <span class="ex">/*</span> verify t_size result */</a>
<a class="sourceLine" id="cb8-54" data-line-number="54">    <span class="kw">if</span> <span class="kw">(</span><span class="ex">t_size</span> != expected_tsize<span class="kw">)</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb8-55" data-line-number="55">       <span class="bu">printf</span>(<span class="st">&quot;[%d] ERROR: t_size=%ld, should be %ld\n&quot;</span>,</a>
<a class="sourceLine" id="cb8-56" data-line-number="56">              <span class="fu">shmem_my_pe()</span>, <span class="ex">t_size</span>, expected_tsize);</a>
<a class="sourceLine" id="cb8-57" data-line-number="57">    <span class="kw">}</span></a>
<a class="sourceLine" id="cb8-58" data-line-number="58"></a>
<a class="sourceLine" id="cb8-59" data-line-number="59">    <span class="ex">/*</span> verify results - note order is indeterminate */</a>
<a class="sourceLine" id="cb8-60" data-line-number="60">    <span class="ex">counts</span> = (int *) <span class="ex">malloc</span>(maxcount * shmem_n_pes() <span class="ex">*</span> sizeof(int));</a>
<a class="sourceLine" id="cb8-61" data-line-number="61">    <span class="ex">bzero</span>(counts,maxcount * shmem_n_pes() <span class="ex">*</span> sizeof(int));</a>
<a class="sourceLine" id="cb8-62" data-line-number="62"></a>
<a class="sourceLine" id="cb8-63" data-line-number="63">    <span class="kw">for</span> <span class="kw">(</span><span class="va">i=</span>0; <span class="ex">i</span><span class="op">&lt;</span>t_size/sizeof(int<span class="kw">)</span>; <span class="ex">i++</span>) <span class="kw">{</span></a>
<a class="sourceLine" id="cb8-64" data-line-number="64">        <span class="ex">counts</span>[target[i]] ++<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-65" data-line-number="65">    <span class="kw">}</span></a>
<a class="sourceLine" id="cb8-66" data-line-number="66"></a>
<a class="sourceLine" id="cb8-67" data-line-number="67">    <span class="kw">for</span> <span class="kw">(</span><span class="va">pe=</span>0; <span class="ex">pe</span><span class="op">&lt;</span>shmem_n_pes(<span class="kw">)</span>; <span class="ex">pe++</span>) <span class="kw">{</span></a>
<a class="sourceLine" id="cb8-68" data-line-number="68">        <span class="kw">if</span> <span class="kw">(</span><span class="ex">counts</span>[pe] != maxcount<span class="kw">)</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb8-69" data-line-number="69">            <span class="bu">printf</span>(<span class="st">&quot;[%d] ERROR: received %d elements of value %d, &quot;</span></a>
<a class="sourceLine" id="cb8-70" data-line-number="70">                   <span class="st">&quot;should be %d\n&quot;</span>, <span class="fu">shmem_my_pe()</span>, <span class="ex">counts</span>[pe], pe, maxcount);</a>
<a class="sourceLine" id="cb8-71" data-line-number="71">        <span class="kw">}</span></a>
<a class="sourceLine" id="cb8-72" data-line-number="72">    <span class="kw">}</span></a>
<a class="sourceLine" id="cb8-73" data-line-number="73"></a>
<a class="sourceLine" id="cb8-74" data-line-number="74">    <span class="fu">shmem_barrier_all()</span>;</a>
<a class="sourceLine" id="cb8-75" data-line-number="75">    <span class="ex">shmem_free</span>(s_sizes);</a>
<a class="sourceLine" id="cb8-76" data-line-number="76">    <span class="ex">shmem_free</span>(s_offsets);</a>
<a class="sourceLine" id="cb8-77" data-line-number="77">    <span class="ex">shmem_free</span>(target);</a>
<a class="sourceLine" id="cb8-78" data-line-number="78">    <span class="ex">shmem_free</span>(source);</a>
<a class="sourceLine" id="cb8-79" data-line-number="79">    <span class="fu">free</span>(counts);</a>
<a class="sourceLine" id="cb8-80" data-line-number="80"></a>
<a class="sourceLine" id="cb8-81" data-line-number="81">    <span class="fu">shmem_finalize()</span>;</a>
<a class="sourceLine" id="cb8-82" data-line-number="82">    <span class="bu">return</span> 0<span class="kw">;</span></a>
<a class="sourceLine" id="cb8-83" data-line-number="83"><span class="kw">}</span></a></code></pre></div>
<h1><a href="../main.html">Index</a></h1></body>
</html>
